"use strict";
exports.__esModule = true;
exports.occtWorkerDeclarations = void 0;
exports.occtWorkerDeclarations = "declare class BitByBitOCCT {\n    occtWorkerManager: OCCTWorkerManager;\n    occt: OCCT;\n    constructor();\n    init(occt: Worker): void;\n}declare class OCCTAssembly {\n    private readonly occWorkerManager;\n    constructor(occWorkerManager: OCCTWorkerManager);\n    /**\n     * Scans assembly\n     * @param inputs Shape to scan\n     * @returns Data for assembly preview\n     */\n    scan(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>): Promise<any>;\n}declare class OCCTBooleans {\n    private readonly occWorkerManager;\n    constructor(occWorkerManager: OCCTWorkerManager);\n    /**\n     * Joins separate objects\n     * @param inputs Objects to join\n     * @returns OpenCascade joined shape\n     * @group booleans\n     * @shortname union\n     * @drawable true\n     */\n    union(inputs: Inputs.OCCT.UnionDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Does boolean difference operation between a main shape and given shapes\n     * @param inputs Main shape and shapes to differ\n     * @returns OpenCascade difference shape\n     * @group booleans\n     * @shortname difference\n     * @drawable true\n     */\n    difference(inputs: Inputs.OCCT.DifferenceDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Does boolean intersection operation between a main shape and given shapes\n     * @param inputs Main shape and shapes to differ\n     * @returns OpenCascade intersection of shapes\n     * @group booleans\n     * @shortname intersection\n     * @drawable true\n     */\n    intersection(inputs: Inputs.OCCT.IntersectionDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n}declare class OCCTFillets {\n    private readonly occWorkerManager;\n    constructor(occWorkerManager: OCCTWorkerManager);\n    /**\n    * Fillets OpenCascade Shapes\n    * @param inputs Shape, radius and edge indexes to fillet\n    * @returns OpenCascade shape with filleted edges\n    * @group 3d\n    * @shortname fillet\n    * @drawable true\n    */\n    filletEdges(inputs: Inputs.OCCT.FilletDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Chamfer OpenCascade Shape edges\n     * @param inputs Shape, distance and edge indexes to chamfer\n     * @returns OpenCascade shape with chamfered edges\n     * @group 3d\n     * @shortname chamfer\n    * @drawable true\n     */\n    chamferEdges(inputs: Inputs.OCCT.ChamferDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Fillets 2d wires or faces\n     * @param inputs Shape\n     * @returns OpenCascade filleted shape result\n     * @group 2d\n     * @shortname fillet\n     * @drawable true\n     */\n    fillet2d(inputs: Inputs.OCCT.FilletDto<Inputs.OCCT.TopoDSWirePointer | Inputs.OCCT.TopoDSFacePointer>): Promise<Inputs.OCCT.TopoDSWirePointer | Inputs.OCCT.TopoDSFacePointer>;\n    /**\n     * Fillets two planar edges into a wire by providing a radius, plane, edges and possible solution index if more than one result exists\n     * @param inputs Definition for fillets\n     * @returns OpenCascade wire shape if solution is found\n     * @group 2d\n     * @shortname fillet 2 edges\n     * @drawable true\n     */\n    filletTwoEdgesInPlaneIntoAWire(inputs: Inputs.OCCT.FilletTwoEdgesInPlaneDto<Inputs.OCCT.TopoDSEdgePointer>): Promise<Inputs.OCCT.TopoDSWirePointer>;\n}declare class OCCTCurves {\n    private readonly occWorkerManager;\n    constructor(occWorkerManager: OCCTWorkerManager);\n    /**\n     * Creates a 2d ellipse. Be sure to use this geometry only for constructive purposes of modeling, but not for representation. You need to transform these curves to edges in order to draw them.\n     * @param inputs 2D Ellipse parameters\n     * @returns OpenCascade Geom2d_ellipse\n     * @group primitives\n     * @shortname ellipse 2d\n     */\n    geom2dEllipse(inputs: Inputs.OCCT.Geom2dEllipseDto): Promise<Inputs.OCCT.Geom2dCurvePointer>;\n    /**\n     * Creates a trimmed curve from the basis curve limited between U1 and U2. This curve can't be drawn.\n     * @param inputs Bounds and strategy for trimming the curve\n     * @returns OpenCascade Geom2d_TrimmedCurve\n     * @group create\n     * @shortname trimmed 2d\n     */\n    geom2dTrimmedCurve(inputs: Inputs.OCCT.Geom2dTrimmedCurveDto<Inputs.OCCT.Geom2dCurvePointer>): Promise<Inputs.OCCT.Geom2dCurvePointer>;\n    /**\n     * Creates a trimmed 2d curve segment between two 2d points. This curve can't be drawn.\n     * @param inputs Two 2d points for start and end\n     * @returns OpenCascade Geom2d_Segment\n     * @group primitives\n     * @shortname segment 2d\n     */\n    geom2dSegment(inputs: Inputs.OCCT.Geom2dSegmentDto): Promise<Inputs.OCCT.Geom2dCurvePointer>;\n    /**\n     * Gets 2d point represented by [number, number] on a curve at parameter.\n     * @param inputs 2D Curve shape and parameter\n     * @returns Point as array of 2 numbers\n     * @group get\n     * @shortname 2d point on curve\n     */\n    get2dPointFrom2dCurveOnParam(inputs: Inputs.OCCT.DataOnGeometryAtParamDto<Inputs.OCCT.Geom2dCurvePointer>): Promise<Inputs.Base.Point2>;\n    /**\n     * Creates a circle geom curve\n     * @param inputs Axis information and radius\n     * @returns Opencascade Geom_Circle curve\n     * @group primitives\n     * @shortname circle\n     * @drawable false\n     */\n    geomCircleCurve(inputs: Inputs.OCCT.CircleDto): Promise<Inputs.OCCT.GeomCurvePointer>;\n    /**\n     * Creates an ellipse geom curve\n     * @param inputs Axis information and radius\n     * @returns Opencascade Geom_Ellipse curve\n     * @group primitives\n     * @shortname ellipse\n     * @drawable false\n     */\n    geomEllipseCurve(inputs: Inputs.OCCT.EllipseDto): Promise<Inputs.OCCT.GeomCurvePointer>;\n}declare class OCCTGeom {\n    readonly curves: OCCTCurves;\n    readonly surfaces: OCCTSurfaces;\n    constructor(occWorkerManager: OCCTWorkerManager);\n}declare class OCCTSurfaces {\n    private readonly occWorkerManager;\n    constructor(occWorkerManager: OCCTWorkerManager);\n    /**\n     * Creates an infinite cylindrical surface that can not be drawn. Be sure to use this geometry only for constructive purposes of modeling, but not for representation.\n     * @param inputs Cylinder parameters\n     * @returns OpenCascade cylindrical surface\n     * @group surfaces\n     * @shortname cylindrical\n     * @drawable false\n     */\n    cylindricalSurface(inputs: Inputs.OCCT.GeomCylindricalSurfaceDto): Promise<Inputs.OCCT.GeomSurfacePointer>;\n    /**\n     * Creates a surface from the face\n     * @param inputs Face shape\n     * @returns OpenCascade geom surface\n     * @group surfaces\n     * @shortname from face\n     * @drawable false\n     */\n    surfaceFromFace(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSFacePointer>): Promise<Inputs.OCCT.GeomSurfacePointer>;\n}declare class OCCTIO {\n    readonly occWorkerManager: OCCTWorkerManager;\n    constructor(occWorkerManager: OCCTWorkerManager);\n    /**\n     * Saves the step file\n     * @param inputs STEP filename and shape to be saved\n     * @returns String of a step file\n     * @group io\n     * @shortname save step\n     * @drawable false\n     */\n    saveShapeSTEP(inputs: Inputs.OCCT.SaveStepDto<Inputs.OCCT.TopoDSShapePointer>): Promise<string>;\n}/**\n * Contains various methods for OpenCascade implementation\n */\ndeclare class OCCT {\n    readonly occWorkerManager: OCCTWorkerManager;\n    readonly shapes: OCCTShapes;\n    readonly geom: OCCTGeom;\n    readonly fillets: OCCTFillets;\n    readonly transforms: OCCTTransforms;\n    readonly operations: OCCTOperations;\n    readonly booleans: OCCTBooleans;\n    io: OCCTIO;\n    constructor(occWorkerManager: OCCTWorkerManager);\n    /**\n     * Creates mesh from the shape\n     * @param inputs shape\n     * @group drawing\n     * @shortname shape to mesh\n     * @drawable false\n     * @ignore true\n     */\n    shapeToMesh(inputs: Inputs.OCCT.ShapeToMeshDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.DecomposedMeshDto>;\n    /**\n     * Deletes shape from the cache to keep memory usage low\n     * @param inputs shape\n     * @group memory\n     * @shortname delete shape\n     */\n    deleteShape(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>): Promise<void>;\n    /**\n     * Deletes shapes from the cache to keep memory usage low\n     * @param inputs shape\n     * @group memory\n     * @shortname delete shapes\n     */\n    deleteShapes(inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSShapePointer>): Promise<void>;\n}declare class OCCTOperations {\n    private readonly occWorkerManager;\n    constructor(occWorkerManager: OCCTWorkerManager);\n    /**\n     * Lofts wires into a shell\n     * @param inputs Loft wires\n     * @returns Resulting loft shape\n     * @group lofts\n     * @shortname loft\n     * @drawable true\n     */\n    loft(inputs: Inputs.OCCT.LoftDto<Inputs.OCCT.TopoDSWirePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Lofts wires into a shell by using many advanced options\n     * @param inputs Advanced loft parameters\n     * @returns Resulting loft shell\n     * @group lofts\n     * @shortname loft adv.\n     * @drawable true\n     */\n    loftAdvanced(inputs: Inputs.OCCT.LoftAdvancedDto<Inputs.OCCT.TopoDSWirePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Extrudes the face along direction\n     * @param inputs Shape to extrude and direction parameter with tolerance\n     * @returns Resulting extruded shape\n     * @group extrusions\n     * @shortname extrude\n     * @drawable true\n     */\n    extrude(inputs: Inputs.OCCT.ExtrudeDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Extrudes the shapes along direction\n     * @param inputs Shapes to extrude and direction parameter with tolerance\n     * @returns Resulting extruded shapes\n     * @group extrusions\n     * @shortname extrude shapes\n     * @drawable true\n     */\n    extrudeShapes(inputs: Inputs.OCCT.ExtrudeShapesDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Splits the face with edges\n     * @param inputs Face to split and edges to split with\n     * @returns Resulting split shape\n     * @group divisions\n     * @shortname split\n     * @drawable true\n     */\n    splitShapeWithShapes(inputs: Inputs.OCCT.SplitDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Revolves the shape around the given direction\n     * @param inputs Revolve parameters\n     * @returns Resulting revolved shape\n     * @group revolutions\n     * @shortname revolve\n     * @drawable true\n     */\n    revolve(inputs: Inputs.OCCT.RevolveDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Rotated extrude that is perofrmed on the shape\n     * @param inputs Rotated extrusion inputs\n     * @returns OpenCascade shape\n     * @group extrusions\n     * @shortname rotated extrude\n     * @drawable true\n     */\n    rotatedExtrude(inputs: Inputs.OCCT.RotationExtrudeDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Pipe shapes along the wire\n     * @param inputs Path wire and shapes along the path\n     * @returns OpenCascade shape\n     * @group pipeing\n     * @shortname pipe\n     * @drawable true\n     */\n    pipe(inputs: Inputs.OCCT.ShapeShapesDto<Inputs.OCCT.TopoDSWirePointer, Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Offset for various shapes\n     * @param inputs Shape to offset and distance with tolerance\n     * @returns Resulting offset shape\n     * @group offsets\n     * @shortname offset\n     * @drawable true\n     */\n    offset(inputs: Inputs.OCCT.OffsetDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Thickens the shape into a solid by an offset distance\n     * @param inputs OpenCascade shape\n     * @returns OpenCascade solid shape\n     * @group offsets\n     * @shortname thicken\n     * @drawable true\n     */\n    makeThickSolidSimple(inputs: Inputs.OCCT.ThisckSolidSimpleDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Thickens the shape into a solid by joining\n     * @param inputs OpenCascade shape and options for thickening\n     * @returns OpenCascade solid shape\n     * @group offsets\n     * @shortname joined thicken\n     * @drawable true\n     */\n    makeThickSolidByJoin(inputs: Inputs.OCCT.ThickSolidByJoinDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n}declare class OCCTCompound {\n    private readonly occWorkerManager;\n    constructor(occWorkerManager: OCCTWorkerManager);\n    /**\n     * Makes the compound shape, which can include any kind of shapes\n     * @param inputs OpenCascade shapes\n     * @returns OpenCascade compounded shape\n     * @group create\n     * @shortname make\n     * @drawable true\n     */\n    makeCompound(inputs: Inputs.OCCT.CompoundShapesDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSCompoundPointer>;\n}declare class OCCTEdge {\n    private readonly occWorkerManager;\n    constructor(occWorkerManager: OCCTWorkerManager);\n    /**\n     * Creates linear edge between two points\n     * @param inputs Two points between which edge should be created\n     * @returns OpenCascade edge\n     * @group primitives\n     * @shortname line\n     * @drawable true\n     */\n    line(inputs: Inputs.OCCT.LineDto): Promise<Inputs.OCCT.TopoDSEdgePointer>;\n    /**\n     * Creates arc edge between three points\n     * @param inputs Shape, radius and edge indexes to fillet\n     * @returns OpenCascade edge\n     * @group primitives\n     * @shortname arc 3 points\n     * @drawable true\n     */\n    arcThroughThreePoints(inputs: Inputs.OCCT.ArcEdgeThreePointsDto): Promise<Inputs.OCCT.TopoDSEdgePointer>;\n    /**\n     * Creates OpenCascade circle edge\n     * @param inputs Circle parameters\n     * @returns OpenCascade circle edge\n     * @group primitives\n     * @shortname circle\n     * @drawable true\n     */\n    createCircleEdge(inputs: Inputs.OCCT.CircleDto): Promise<Inputs.OCCT.TopoDSEdgePointer>;\n    /**\n     * Creates OpenCascade ellipse edge\n     * @param inputs Ellipse parameters\n     * @returns OpenCascade ellipse edge\n     * @group primitives\n     * @shortname ellipse\n     * @drawable true\n     */\n    createEllipseEdge(inputs: Inputs.OCCT.EllipseDto): Promise<Inputs.OCCT.TopoDSEdgePointer>;\n    /**\n     * Removes internal faces for the shape\n     * @param inputs Shape\n     * @returns OpenCascade shape with no internal edges\n     * @group shapes\n     * @shortname remove internal\n     * @drawable true\n     */\n    removeInternalEdges(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Gets the edge by providing an index from the shape\n     * @param inputs Shape\n     * @returns OpenCascade edge\n     * @group shapes\n     * @shortname get edge\n     * @drawable true\n     */\n    getEdge(inputs: Inputs.OCCT.ShapeIndexDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSEdgePointer>;\n    /**\n     * Gets the edges of a shape in a list\n     * @param inputs Shape\n     * @returns OpenCascade edge list\n     * @group shapes\n     * @shortname get edges\n     * @drawable true\n     */\n    getEdges(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSEdgePointer[]>;\n    /**\n     * Creates an edge from geom curve and geom surface\n     * @param inputs shapes are expected to contain 2 array elements - first is geom curve, second geom surface\n     * @returns OpenCascade TopoDS_Edge\n     * @group from\n     * @shortname 2d curve and surface\n     * @drawable true\n     */\n    makeEdgeFromGeom2dCurveAndSurface(inputs: Inputs.OCCT.EdgeFromGeom2dCurveAndSurfaceDto<Inputs.OCCT.Geom2dCurvePointer, Inputs.OCCT.GeomSurfacePointer>): Promise<Inputs.OCCT.TopoDSEdgePointer>;\n    /**\n     * Gets corner points of edges for a shape. There's no order guarantee here. All duplicates are removed, so when three edges form one corner, that will be represented by a single point in the list.\n     * @param inputs Shape that contains edges - wire, face, shell, solid\n     * @returns List of points\n     * @group get\n     * @shortname corners\n     * @drawable true\n     */\n    getCornerPointsOfEdgesForShape(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.Base.Point3[]>;\n    /**\n     * Gets the edge length\n     * @param inputs edge\n     * @returns Length\n     * @group get\n     * @shortname length\n     * @drawable false\n     */\n    getEdgeLength(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSEdgePointer>): Promise<number>;\n    /**\n     * Gets the lengths of the edges\n     * @param inputs edges\n     * @returns Lengths\n     * @group get\n     * @shortname lengths\n     * @drawable false\n     */\n    getEdgesLengths(inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSEdgePointer>): Promise<number[]>;\n    /**\n     * Gets the center of mass for the edge\n     * @param inputs edge\n     * @returns Point representing center of mass\n     * @group get\n     * @shortname center of mass\n     * @drawable true\n     */\n    getEdgeCenterOfMass(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSEdgePointer>): Promise<Inputs.Base.Point3>;\n    /**\n     * Gets the centers of mass for the edges\n     * @param inputs edges\n     * @returns Points representing centers of mass\n     * @group get\n     * @shortname centers of mass\n     * @drawable true\n     */\n    getEdgesCentersOfMass(inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSEdgePointer>): Promise<Inputs.Base.Point3[]>;\n    /**\n     * Gets the point on edge at param\n     * @param input edge\n     * @returns Point on param\n     * @group extract\n     * @shortname point at param\n     * @drawable true\n     */\n    pointOnEdgeAtParam(inputs: Inputs.OCCT.DataOnGeometryAtParamDto<Inputs.OCCT.TopoDSEdgePointer>): Promise<Inputs.Base.Point3>;\n    /**\n     * Gets the tangent vector on edge at param\n     * @param input edge\n     * @returns Tangent vector on param\n     * @group extract\n     * @shortname tangent at param\n     * @drawable true\n     */\n    tangentOnEdgeAtParam(inputs: Inputs.OCCT.DataOnGeometryAtParamDto<Inputs.OCCT.TopoDSEdgePointer>): Promise<Inputs.Base.Point3>;\n    /**\n     * Gets the point on edge at length\n     * @param input edge and length\n     * @returns Point on edge\n     * @group extract\n     * @shortname point at length\n     * @drawable true\n     */\n    pointOnEdgeAtLength(inputs: Inputs.OCCT.DataOnGeometryAtLengthDto<Inputs.OCCT.TopoDSEdgePointer>): Promise<Inputs.Base.Point3>;\n    /**\n     * Gets the tangent vector on edge at length\n     * @param input edge and length\n     * @returns Tangent vector on edge\n     * @group extract\n     * @shortname tangent at length\n     * @drawable true\n     */\n    tangentOnEdgeAtLength(inputs: Inputs.OCCT.DataOnGeometryAtLengthDto<Inputs.OCCT.TopoDSEdgePointer>): Promise<Inputs.Base.Point3>;\n    /**\n     * Gets the start point on edge\n     * @param input edge\n     * @returns Start point\n     * @group extract\n     * @shortname start point\n     * @drawable true\n     */\n    startPointOnEdge(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSEdgePointer>): Promise<Inputs.Base.Point3>;\n    /**\n     * Gets the end point on edge\n     * @param input edge\n     * @returns End point\n     * @group extract\n     * @shortname end point\n     * @drawable true\n     */\n    endPointOnEdge(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSEdgePointer>): Promise<Inputs.Base.Point3>;\n    /**\n     * Divides edge by params to points\n     * @param input edge and division params\n     * @returns Points\n     * @group extract\n     * @shortname points by params\n     * @drawable true\n     */\n    divideEdgeByParamsToPoints(inputs: Inputs.OCCT.DivideDto<Inputs.OCCT.TopoDSEdgePointer>): Promise<Inputs.Base.Point3[]>;\n    /**\n     * Divides edge by length to points\n     * @param input edge and division params\n     * @returns Points\n     * @group extract\n     * @shortname points by distance\n     * @drawable true\n     */\n    divideEdgeByEqualDistanceToPoints(inputs: Inputs.OCCT.DivideDto<Inputs.OCCT.TopoDSEdgePointer>): Promise<Inputs.Base.Point3[]>;\n}declare class OCCTFace {\n    private readonly occWorkerManager;\n    constructor(occWorkerManager: OCCTWorkerManager);\n    /**\n     * Creates a face from wire\n     * @param inputs OpenCascade wire shape and indication if face should be planar\n     * @returns OpenCascade face shape\n     * @group from\n     * @shortname wire\n     * @drawable true\n     */\n    createFaceFromWire(inputs: Inputs.OCCT.FaceFromWireDto<Inputs.OCCT.TopoDSWirePointer>): Promise<Inputs.OCCT.TopoDSFacePointer>;\n    /**\n     * Creates faces from wires\n     * @param inputs OpenCascade wire shape and indication if face should be planar\n     * @returns OpenCascade face shape\n     * @group from\n     * @shortname wires\n     * @drawable true\n     */\n    createFacesFromWires(inputs: Inputs.OCCT.FaceFromWireDto<Inputs.OCCT.TopoDSWirePointer>): Promise<Inputs.OCCT.TopoDSFacePointer[]>;\n    /**\n     * Creates a face from the surface\n     * @param inputs Face shape\n     * @returns OpenCascade surface\n     * @group from\n     * @shortname surface\n     * @drawable true\n     */\n    faceFromSurface(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.GeomSurfacePointer>): Promise<Inputs.OCCT.TopoDSFacePointer>;\n    /**\n     * Creates a face from the surface and a wire\n     * @param inputs OpenCascade surface, a wire and indication wether face should be created inside or not\n     * @returns Face shape\n     * @group from\n     * @shortname surface and wire\n     * @drawable true\n     */\n    faceFromSurfaceAndWire(inputs: Inputs.OCCT.FaceFromSurfaceAndWireDto<Inputs.OCCT.GeomSurfacePointer, Inputs.OCCT.TopoDSWirePointer>): Promise<Inputs.OCCT.TopoDSFacePointer>;\n    /**\n     * Creates OpenCascade Polygon face\n     * @param inputs Polygon points\n     * @returns OpenCascade polygon face\n     * @group primitives\n     * @shortname polygon\n     * @drawable true\n     */\n    createPolygonFace(inputs: Inputs.OCCT.PolygonDto): Promise<Inputs.OCCT.TopoDSFacePointer>;\n    /**\n     * Creates OpenCascade circle face\n     * @param inputs Circle parameters\n     * @returns OpenCascade circle face\n     * @group primitives\n     * @shortname circle\n     * @drawable true\n     */\n    createCircleFace(inputs: Inputs.OCCT.CircleDto): Promise<Inputs.OCCT.TopoDSFacePointer>;\n    /**\n     * Creates OpenCascade ellipse face\n     * @param inputs Ellipse parameters\n     * @returns OpenCascade ellipse face\n     * @group primitives\n     * @shortname ellipse\n     * @drawable true\n     */\n    createEllipseFace(inputs: Inputs.OCCT.EllipseDto): Promise<Inputs.OCCT.TopoDSFacePointer>;\n    /**\n     * Creates OpenCascade square face\n     * @param inputs Square parameters\n     * @returns OpenCascade square face\n     * @group primitives\n     * @shortname square\n     * @drawable true\n     */\n    createSquareFace(inputs: Inputs.OCCT.SquareDto): Promise<Inputs.OCCT.TopoDSFacePointer>;\n    /**\n     * Creates OpenCascade rectangle face\n     * @param inputs rectangle parameters\n     * @returns OpenCascade rectangle\n     * @group primitives\n     * @shortname rectangle\n     * @drawable true\n     */\n    createRectangleFace(inputs: Inputs.OCCT.RectangleDto): Promise<Inputs.OCCT.TopoDSFacePointer>;\n    /**\n     * Gets the face by providing an index from the shape\n     * @param inputs Shape\n     * @returns OpenCascade face\n     * @group get\n     * @shortname face\n     * @drawable true\n     */\n    getFace(inputs: Inputs.OCCT.ShapeIndexDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSFacePointer>;\n    /**\n     * Gets the faces of the shape in a list\n     * @param inputs Shape\n     * @returns OpenCascade faces array\n     * @group get\n     * @shortname faces\n     * @drawable true\n     */\n    getFaces(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSFacePointer[]>;\n    /**\n     * Computes reversed face from input face\n     * @param inputs Face\n     * @returns OpenCascade face\n     * @group get\n     * @shortname reversed\n     * @drawable true\n     */\n    reversedFace(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSFacePointer>): Promise<Inputs.OCCT.TopoDSFacePointer>;\n    /**\n     * Subdivides a face to point grid\n     * @param inputs Face and params for subdivision\n     * @returns points\n     * @group extract\n     * @shortname points\n     * @drawable true\n     */\n    subdivideToPoints(inputs: Inputs.OCCT.FaceSubdivisionDto<Inputs.OCCT.TopoDSFacePointer>): Promise<Inputs.Base.Point3[]>;\n    /**\n     * Subdivides a face to point grid with shifts and removals on nth uv rows or columns\n     * @param inputs Face and params for subdivision\n     * @returns points\n     * @group extract\n     * @shortname points nth\n     * @drawable true\n     */\n    subdivideToPointsControlled(inputs: Inputs.OCCT.FaceSubdivisionControlledDto<Inputs.OCCT.TopoDSFacePointer>): Promise<Inputs.Base.Point3[]>;\n    /**\n     * Subdivides a face to normals grid\n     * @param inputs Face and params for subdivision\n     * @returns normal vectors\n     * @group extract\n     * @shortname normals\n     * @drawable true\n     */\n    subdivideToNormals(inputs: Inputs.OCCT.FaceSubdivisionDto<Inputs.OCCT.TopoDSFacePointer>): Promise<Inputs.Base.Vector3[]>;\n    /**\n     * Subdivides a face to uv grid\n     * @param inputs Face and params for subdivision\n     * @returns uv params in array\n     * @group extract\n     * @shortname uvs\n     * @drawable true\n     */\n    subdivideToUV(inputs: Inputs.OCCT.FaceSubdivisionDto<Inputs.OCCT.TopoDSFacePointer>): Promise<Inputs.Base.Point2[]>;\n    /**\n     * Get point on UV where U and V are described between 0 and 1. These will be mapped to real bounds.\n     * @param inputs Face and params for subdivision\n     * @returns point\n     * @group extract\n     * @shortname point on uv\n     * @drawable true\n     */\n    pointOnUV(inputs: Inputs.OCCT.DataOnUVDto<Inputs.OCCT.TopoDSFacePointer>): Promise<Inputs.Base.Point3>;\n    /**\n     * Get normal on UV where U and V are described between 0 and 1. These will be mapped to real bounds.\n     * @param inputs Face and params for subdivision\n     * @returns normal vector\n     * @group extract\n     * @shortname normal on uv\n     * @drawable true\n     */\n    normalOnUV(inputs: Inputs.OCCT.DataOnUVDto<Inputs.OCCT.TopoDSFacePointer>): Promise<Inputs.Base.Vector3>;\n    /**\n     * Get points on UVs where U and V are described between 0 and 1 in two dimensional arrays. These will be mapped to real bounds.\n     * @param inputs Face and params for subdivision\n     * @returns points\n     * @group extract\n     * @shortname points on uvs\n     * @drawable true\n     */\n    pointsOnUVs(inputs: Inputs.OCCT.DataOnUVsDto<Inputs.OCCT.TopoDSFacePointer>): Promise<Inputs.Base.Point3[]>;\n    /**\n     * Get normals on UVs where U and V are described between 0 and 1 in two dimensional arrays. These will be mapped to real bounds.\n     * @param inputs Face and params for subdivision\n     * @returns normals\n     * @group extract\n     * @shortname normals on uvs\n     * @drawable true\n     */\n    normalsOnUVs(inputs: Inputs.OCCT.DataOnUVsDto<Inputs.OCCT.TopoDSFacePointer>): Promise<Inputs.Base.Vector3[]>;\n    /**\n     * Subdivides a face to points along a line on parameter\n     * @param inputs Face and params for subdivision\n     * @returns points\n     * @group extract\n     * @shortname points on param\n     * @drawable true\n     */\n    subdivideToPointsOnParam(inputs: Inputs.OCCT.FaceLinearSubdivisionDto<Inputs.OCCT.TopoDSFacePointer>): Promise<Inputs.Base.Point3[]>;\n    /**\n     * Gets the U min bound of the face\n     * @param inputs OCCT Face\n     * @returns u min bound\n     * @group get\n     * @shortname u min\n     * @drawable false\n     */\n    getUMinBound(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSFacePointer>): Promise<number>;\n    /**\n     * Gets the U max bound of the face\n     * @param inputs OCCT Face\n     * @returns u max bound\n     * @group get\n     * @shortname u max\n     * @drawable false\n     */\n    getUMaxBound(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSFacePointer>): Promise<number>;\n    /**\n     * Gets the V min bound of the face\n     * @param inputs OCCT Face\n     * @returns v min bound\n     * @group get\n     * @shortname v min\n     * @drawable false\n     */\n    getVMinBound(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSFacePointer>): Promise<number>;\n    /**\n     * Gets the V max bound of the face\n     * @param inputs OCCT Face\n     * @returns v max bound\n     * @group get\n     * @shortname v max\n     * @drawable false\n     */\n    getVMaxBound(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSFacePointer>): Promise<number>;\n    /**\n     * Get the area of the face\n     * @param inputs OCCT Face\n     * @returns area\n     * @group get\n     * @shortname face area\n     * @drawable false\n     */\n    getFaceArea(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSFacePointer>): Promise<number>;\n    /**\n     * Get the areas of the faces\n     * @param inputs OCCT Faces\n     * @returns areas\n     * @group get\n     * @shortname areas of faces\n     * @drawable false\n     */\n    getFacesAreas(inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSFacePointer>): Promise<number[]>;\n    /**\n     * Get the face center of mass point\n     * @param inputs OCCT Face\n     * @returns point\n     * @group get\n     * @shortname center of mass\n     * @drawable true\n     */\n    getFaceCenterOfMass(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSFacePointer>): Promise<Inputs.Base.Point3>;\n    /**\n     * Get the face center of mass point\n     * @param inputs OCCT Faces\n     * @returns points\n     * @group get\n     * @shortname centers of mass\n     * @drawable true\n     */\n    getFacesCentersOfMass(inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSFacePointer>): Promise<Inputs.Base.Point3[]>;\n}declare class OCCTShapes {\n    readonly edge: OCCTEdge;\n    readonly wire: OCCTWire;\n    readonly face: OCCTFace;\n    readonly shell: OCCTShell;\n    readonly solid: OCCTSolid;\n    readonly compound: OCCTCompound;\n    constructor(occWorkerManager: OCCTWorkerManager);\n}declare class OCCTShell {\n    private readonly occWorkerManager;\n    constructor(occWorkerManager: OCCTWorkerManager);\n    /**\n     * Creates a shell from faces\n     * @param inputs OpenCascade shell and faces\n     * @returns OpenCascade shell\n     * @group create\n     * @shortname sew\n     * @drawable true\n     */\n    sewFaces(inputs: Inputs.OCCT.SewDto<Inputs.OCCT.TopoDSFacePointer>): Promise<Inputs.OCCT.TopoDSShellPointer>;\n    /**\n     * Get shell surface area\n     * @param inputs shell shape\n     * @returns Surface area\n     * @group get\n     * @shortname area\n     * @drawable false\n     */\n    getShellSurfaceArea(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShellPointer>): Promise<number>;\n}declare class OCCTSolid {\n    private readonly occWorkerManager;\n    constructor(occWorkerManager: OCCTWorkerManager);\n    /**\n     * Creates Solid From shell that must be closed\n     * @param inputs Closed shell to make into solid\n     * @returns OpenCascade Solid\n     * @group from\n     * @shortname shell\n     * @drawable true\n     */\n    fromClosedShell(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSShellPointer>): Promise<Inputs.OCCT.TopoDSSolidPointer>;\n    /**\n     * Creates OpenCascade Box\n     * @param inputs Box size and center\n     * @returns OpenCascade Box\n     * @group primitives\n     * @shortname box\n     * @drawable true\n     */\n    createBox(inputs: Inputs.OCCT.BoxDto): Promise<Inputs.OCCT.TopoDSSolidPointer>;\n    /**\n     * Creates OpenCascade Box from corner\n     * @param inputs Box size and corner coordinates\n     * @returns OpenCascade Box\n     * @group primitives\n     * @shortname box corner\n     * @drawable true\n     */\n    createBoxFromCorner(inputs: Inputs.OCCT.BoxFromCornerDto): Promise<Inputs.OCCT.TopoDSSolidPointer>;\n    /**\n     * Creates OpenCascade Cylinder\n     * @param inputs Cylinder parameters\n     * @returns OpenCascade Cylinder\n     * @group primitives\n     * @shortname cylinder\n     * @drawable true\n     */\n    createCylinder(inputs: Inputs.OCCT.CylinderDto): Promise<Inputs.OCCT.TopoDSSolidPointer>;\n    /**\n     * Creates OpenCascade Cylinders on simple bit by bit lines represented by two points\n     * @param inputs Cylinder parameters\n     * @returns OpenCascade Cylinder\n     * @group primitives\n     * @shortname cylinders on lines\n     * @drawable true\n     */\n    createCylindersOnLines(inputs: Inputs.OCCT.CylindersOnLinesDto): Promise<Inputs.OCCT.TopoDSSolidPointer[]>;\n    /**\n     * Creates OpenCascade Sphere\n     * @param inputs Sphere radius and center\n     * @returns OpenCascade Sphere\n     * @group primitives\n     * @shortname sphere\n     * @drawable true\n     */\n    createSphere(inputs: Inputs.OCCT.SphereDto): Promise<Inputs.OCCT.TopoDSSolidPointer>;\n    /**\n     * Creates OpenCascade Cone\n     * @param inputs Cone parameters\n     * @returns OpenCascade cone shape\n     * @group primitives\n     * @shortname cone\n     * @drawable true\n     */\n    createCone(inputs: Inputs.OCCT.ConeDto): Promise<Inputs.OCCT.TopoDSSolidPointer>;\n    /**\n     * Get solid surface area\n     * @param inputs Closed solid shape\n     * @returns Surface area\n     * @group get\n     * @shortname area\n     * @drawable false\n     */\n    getSolidSurfaceArea(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSSolidPointer>): Promise<number>;\n    /**\n    * Get solid volume\n    * @param inputs Closed solid shape\n    * @returns volume\n    * @group get\n    * @shortname volume\n    * @drawable false\n    */\n    getSolidVolume(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSSolidPointer>): Promise<number>;\n    /**\n    * Get solids volumes\n    * @param inputs Closed solid shapes\n    * @returns volumes\n    * @group get\n    * @shortname volumes\n    * @drawable false\n    */\n    getSolidsVolumes(inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSSolidPointer>): Promise<number[]>;\n    /**\n    * Get solid center of mass\n    * @param inputs Closed solid shape\n    * @returns center of mass point\n    * @group get\n    * @shortname center of mass\n    * @drawable true\n    */\n    getSolidCenterOfMass(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSSolidPointer>): Promise<Inputs.Base.Point3>;\n    /**\n     * Get centers of mass of solids\n     * @param inputs Closed solid shapes\n     * @returns Points indicating centers of mass\n    * @group get\n    * @shortname centers of mass\n    * @drawable true\n     */\n    getSolidsCentersOfMass(inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSSolidPointer>): Promise<Inputs.Base.Point3[]>;\n}declare class OCCTWire {\n    private readonly occWorkerManager;\n    constructor(occWorkerManager: OCCTWorkerManager);\n    /**\n     * Creates OpenCascade Polygon wire\n     * @param inputs Polygon points\n     * @returns OpenCascade polygon wire shape\n     * @group via points\n     * @shortname polygon\n     * @drawable true\n     */\n    createPolygonWire(inputs: Inputs.OCCT.PolygonDto): Promise<Inputs.OCCT.TopoDSWirePointer>;\n    /**\n    * Creates OpenCascade Bezier wire\n    * @param inputs Points through which to make bezier curve\n    * @returns OpenCascade Bezier wire\n    * @group via points\n    * @shortname bezier\n    * @drawable true\n    */\n    createBezier(inputs: Inputs.OCCT.BezierDto): Promise<Inputs.OCCT.TopoDSWirePointer>;\n    /**\n     * Creates OpenCascade BSpline wire from points. This method can be used to create nicely shaped (periodic) loops.\n     * @param inputs Points through which to make the curve, periodic bool and tolerance\n     * @returns OpenCascade BSpline wire\n     * @group via points\n     * @shortname interpolate\n     * @drawable true\n     */\n    interpolatePoints(inputs: Inputs.OCCT.InterpolationDto): Promise<Inputs.OCCT.TopoDSWirePointer>;\n    /**\n     * Creates OpenCascade BSPline wire\n     * @param inputs Points through which to make BSpline\n     * @returns OpenCascade BSpline wire\n     * @group via points\n     * @shortname bspline\n     * @drawable true\n     */\n    createBSpline(inputs: Inputs.OCCT.BSplineDto): Promise<Inputs.OCCT.TopoDSWirePointer>;\n    /**\n     * Combines OpenCascade edges and wires into a single wire\n     * @param inputs List of shapes of edges and wires\n     * @returns OpenCascade wire\n     * @group build\n     * @shortname combine\n     * @drawable true\n     */\n    combineEdgesAndWiresIntoAWire(inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSWirePointer | Inputs.OCCT.TopoDSEdgePointer>): Promise<Inputs.OCCT.TopoDSWirePointer>;\n    /**\n     * Adds OpenCascade edges and wires into another wire\n     * @param inputs List of shapes of edges and wires and a single shape wire to which edges need to be added\n     * @returns OpenCascade wire\n     * @group build\n     * @shortname extend\n     * @drawable true\n     */\n    addEdgesAndWiresToWire(inputs: Inputs.OCCT.ShapeShapesDto<Inputs.OCCT.TopoDSWirePointer, Inputs.OCCT.TopoDSWirePointer | Inputs.OCCT.TopoDSEdgePointer>): Promise<Inputs.OCCT.TopoDSWirePointer>;\n    /**\n    * Divides OpenCascade wire to points blindly following its parametric space\n    * @param inputs Describes into how many points should the wire be divided\n    * @returns Points on wire\n    * @group extract\n    * @shortname points by params\n    * @drawable true\n    */\n    divideWireByParamsToPoints(inputs: Inputs.OCCT.DivideDto<Inputs.OCCT.TopoDSWirePointer>): Promise<Inputs.Base.Point3[]>;\n    /**\n    * Divides OpenCascade wire to equal distance points\n    * @param inputs Describes into how many points should the wire be divided\n    * @returns Points on wire\n    * @group extract\n    * @shortname points by distance\n    * @drawable true\n    */\n    divideWireByEqualDistanceToPoints(inputs: Inputs.OCCT.DivideDto<Inputs.OCCT.TopoDSWirePointer>): Promise<Inputs.Base.Point3[]>;\n    /**\n    * Evaluates point on a wire at parameter value between 0 and 1, being start and end points\n    * @param inputs Wire shape and parameter\n    * @returns Point as array of 3 numbers\n    * @group extract\n    * @shortname point at param\n    * @drawable true\n    */\n    pointOnWireAtParam(inputs: Inputs.OCCT.DataOnGeometryAtParamDto<Inputs.OCCT.TopoDSWirePointer>): Promise<Inputs.Base.Point3>;\n    /**\n    * Evaluates point on a wire at certain length\n    * @param inputs Wire shape and length value\n    * @returns Point as array of 3 numbers\n    * @group extract\n    * @shortname point at length\n    * @drawable true\n    */\n    pointOnWireAtLength(inputs: Inputs.OCCT.DataOnGeometryAtLengthDto<Inputs.OCCT.TopoDSWirePointer>): Promise<Inputs.Base.Point3>;\n    /**\n    * Evaluates tangent vector on a wire at parameter value between 0 and 1, being start and end points\n    * @param inputs Wire shape and parameter\n    * @returns Tangent vector as array of 3 numbers\n    * @group extract\n    * @shortname tangent at param\n    * @drawable true\n    */\n    tangentOnWireAtParam(inputs: Inputs.OCCT.DataOnGeometryAtParamDto<Inputs.OCCT.TopoDSWirePointer>): Promise<Inputs.Base.Vector3>;\n    /**\n    * Evaluates tangent vector on a wire at certain length\n    * @param inputs Wire shape and length value\n    * @returns Tangent vector as array of 3 numbers\n    * @group extract\n    * @shortname tangent at length\n    * @drawable true\n    */\n    tangentOnWireAtLength(inputs: Inputs.OCCT.DataOnGeometryAtLengthDto<Inputs.OCCT.TopoDSWirePointer>): Promise<Inputs.Base.Vector3>;\n    /**\n    * Computes 3 derivative vectors of a curve at a given length\n    * @param inputs Wire shape and length value\n    * @returns Three arrays of vectors. Each vector represents derivatives in order - first, second, third\n    * @group extract\n    * @shortname derivatives at length\n    * @drawable false\n    */\n    derivativesOnWireAtLength(inputs: Inputs.OCCT.DataOnGeometryAtLengthDto<Inputs.OCCT.TopoDSWirePointer>): Promise<[Inputs.Base.Vector3, Inputs.Base.Vector3, Inputs.Base.Vector3]>;\n    /**\n    * Computes 3 derivative vectors of a curve on parameter between 0 and 1.\n    * @param inputs Wire shape and parameter value\n    * @returns Three arrays of vectors. Each vector represents derivatives in order - first, second, third\n    * @group extract\n    * @shortname derivatives at param\n    * @drawable false\n    */\n    derivativesOnWireAtParam(inputs: Inputs.OCCT.DataOnGeometryAtParamDto<Inputs.OCCT.TopoDSWirePointer>): Promise<[Inputs.Base.Vector3, Inputs.Base.Vector3, Inputs.Base.Vector3]>;\n    /**\n    * Computes the star point on the wire at param 0\n    * @param inputs Wire shape\n    * @returns The length of the wire\n    * @group extract\n    * @shortname start point\n    * @drawable true\n    */\n    startPointOnWire(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSWirePointer>): Promise<Inputs.Base.Point3>;\n    /**\n    * Computes the end point on the wire at param 1\n    * @param inputs Wire shape\n    * @returns The length of the wire\n    * @group extract\n    * @shortname end point\n    * @drawable true\n    */\n    endPointOnWire(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSWirePointer>): Promise<Inputs.Base.Point3>;\n    /**\n     * Creates OpenCascade circle wire\n     * @param inputs Circle parameters\n     * @returns OpenCascade circle wire\n     * @group primitives\n     * @shortname circle\n     * @drawable true\n     */\n    createCircleWire(inputs: Inputs.OCCT.CircleDto): Promise<Inputs.OCCT.TopoDSWirePointer>;\n    /**\n     * Creates OpenCascade square wire\n     * @param inputs Square parameters\n     * @returns OpenCascade square wire\n     * @group primitives\n     * @shortname square\n     * @drawable true\n     */\n    createSquareWire(inputs: Inputs.OCCT.SquareDto): Promise<Inputs.OCCT.TopoDSWirePointer>;\n    /**\n     * Creates OpenCascade star wire\n     * @param inputs star parameters\n     * @returns OpenCascade star wire\n     * @group primitives\n     * @shortname star\n     * @drawable true\n     */\n    createStarWire(inputs: Inputs.OCCT.StarDto): Promise<Inputs.OCCT.TopoDSWirePointer>;\n    /**\n     * Creates OpenCascade n-gon wire\n     * @param inputs ngon parameters\n     * @returns OpenCascade ngon wire\n     * @group primitives\n     * @shortname n-gon\n     * @drawable true\n     */\n    createNGonWire(inputs: Inputs.OCCT.NGonWireDto): Promise<Inputs.OCCT.TopoDSWirePointer>;\n    /**\n     * Creates n  parallelogram wire\n     * @param inputs parallelogram parameters\n     * @returns OpenCascade star wire\n     * @group primitives\n     * @shortname parallelogram\n     * @drawable true\n     */\n    createParallelogramWire(inputs: Inputs.OCCT.ParallelogramDto): Promise<Inputs.OCCT.TopoDSWirePointer>;\n    /**\n     * Creates OpenCascade rectangle wire\n     * @param inputs rectangle parameters\n     * @returns OpenCascade rectangle\n     * @group primitives\n     * @shortname rectangle\n     * @drawable true\n     */\n    createRectangleWire(inputs: Inputs.OCCT.RectangleDto): Promise<Inputs.OCCT.TopoDSWirePointer>;\n    /**\n     * Creates OpenCascade ellipse wire\n     * @param inputs Ellipse parameters\n     * @returns OpenCascade ellipse wire\n     * @group primitives\n     * @shortname ellipse\n     * @drawable true\n     */\n    createEllipseWire(inputs: Inputs.OCCT.EllipseDto): Promise<Inputs.OCCT.TopoDSWirePointer>;\n    /**\n     * Gets the wire by providing an index from the shape\n     * @param inputs Shape\n     * @returns OpenCascade wire\n     * @group get\n     * @shortname wire\n     * @drawable true\n     */\n    getWire(inputs: Inputs.OCCT.ShapeIndexDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSWirePointer>;\n    /**\n     * Gets the wires by providing an index from the shape\n     * @param inputs Shape\n     * @returns OpenCascade wires\n     * @group get\n     * @shortname wires\n     * @drawable true\n     */\n    getWires(inputs: Inputs.OCCT.ShapeIndexDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSWirePointer>;\n    /**\n     * Computes reversed wire from input wire\n     * @param inputs Shape\n     * @returns OpenCascade wire\n     * @group get\n     * @shortname reversed\n     * @drawable true\n     */\n    reversedWire(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSWirePointer>): Promise<Inputs.OCCT.TopoDSWirePointer>;\n    /**\n     * Gets the wire length\n     * @param inputs wire\n     * @returns Length\n     * @group get\n     * @shortname length\n     * @drawable false\n     */\n    getWireLength(inputs: Inputs.OCCT.ShapeDto<Inputs.OCCT.TopoDSWirePointer>): Promise<number>;\n    /**\n     * Gets the lengths of wires\n     * @param inputs wires\n     * @returns Lengths\n     * @group get\n     * @shortname lengths\n     * @drawable false\n     */\n    getWiresLengths(inputs: Inputs.OCCT.ShapesDto<Inputs.OCCT.TopoDSWirePointer>): Promise<number[]>;\n    /**\n     * Places a wire on the face by mapping it's 2d coordinates to UV space. Wire must be positioned on the ground XZ plane for this to work.\n     * @param inputs two shapes - first a wire and second a face\n     * @returns OpenCascade wire\n     * @group place\n     * @shortname wire on face\n     * @drawable true\n     */\n    placeWireOnFace(inputs: Inputs.OCCT.WireOnFaceDto<Inputs.OCCT.TopoDSWirePointer, Inputs.OCCT.TopoDSFacePointer>): Promise<Inputs.OCCT.TopoDSWirePointer>;\n    /**\n     * Places multiple wires on the face by mapping it's 2d coordinates to UV space. Wires must be positioned on the ground XZ plane for this to work.\n     * @param inputs a face and a list of wires\n     * @returns OpenCascade wires\n     * @group place\n     * @shortname wires on face\n     * @drawable true\n     */\n    placeWiresOnFace(inputs: Inputs.OCCT.ShapeShapesDto<Inputs.OCCT.TopoDSFacePointer, Inputs.OCCT.TopoDSWirePointer>): Promise<Inputs.OCCT.TopoDSWirePointer[]>;\n}declare class OCCTTransforms {\n    private readonly occWorkerManager;\n    constructor(occWorkerManager: OCCTWorkerManager);\n    /**\n     * Transforms the shape\n     * @param inputs Transformation description\n     * @returns OpenCascade shape\n     * @group on single shape\n     * @shortname transform\n     * @drawable true\n     */\n    transform(inputs: Inputs.OCCT.TransformDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Rotate the shape\n     * @param inputs Rotation description\n     * @returns OpenCascade shape\n     * @group on single shape\n     * @shortname rotate\n     * @drawable true\n     */\n    rotate(inputs: Inputs.OCCT.RotateDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Align the shape\n     * @param inputs Align description\n     * @returns OpenCascade shape\n     * @group on single shape\n     * @shortname align\n     * @drawable true\n     */\n    align(inputs: Inputs.OCCT.AlignDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Translates the shape\n     * @param inputs Translation description\n     * @returns OpenCascade shape\n     * @group on single shape\n     * @shortname translate\n     * @drawable true\n     */\n    translate(inputs: Inputs.OCCT.TranslateDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Scales the shape\n     * @param inputs Scale description\n     * @returns OpenCascade shape\n     * @group on single shape\n     * @shortname scale\n     * @drawable true\n     */\n    scale(inputs: Inputs.OCCT.ScaleDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Scales the shape in 3D\n     * @param inputs Scale 3D description\n     * @returns OpenCascade scaled shape\n     * @group on single shape\n     * @shortname scale 3d\n     * @drawable true\n     */\n    scale3d(inputs: Inputs.OCCT.Scale3DDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Mirrors the shape\n     * @param inputs Mirror axis origin, axis direction and shape\n     * @returns OpenCascade shape\n     * @group on single shape\n     * @shortname mirror\n     * @drawable true\n     */\n    mirror(inputs: Inputs.OCCT.MirrorDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Mirrors the shape along the normal and origin\n     * @param inputs Normal for mirroring with origin\n     * @returns OpenCascade shape\n     * @group on single shape\n     * @shortname mirror normal\n     * @drawable true\n     */\n    mirrorAlongNormal(inputs: Inputs.OCCT.MirrorAlongNormalDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer>;\n    /**\n     * Transforms the array of shapes with transformations\n     * @param inputs Transformation descriptions\n     * @returns OpenCascade shapes\n     * @group on multiple shapes\n     * @shortname transforms\n     * @drawable true\n     */\n    transformShapes(inputs: Inputs.OCCT.TransformShapesDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer[]>;\n    /**\n     * Rotate the shapes with rotations\n     * @param inputs Rotation descriptions\n     * @returns OpenCascade shapes\n     * @group on multiple shapes\n     * @shortname rotations\n     * @drawable true\n     */\n    rotateShapes(inputs: Inputs.OCCT.RotateShapesDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer[]>;\n    /**\n     * Align the shapes with alignments\n     * @param inputs Align descriptions\n     * @returns OpenCascade shapes\n     * @group on multiple shapes\n     * @shortname alignments\n     * @drawable true\n     */\n    alignShapes(inputs: Inputs.OCCT.AlignShapesDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer[]>;\n    /**\n     * Translates the shapes with translations\n     * @param inputs Translation descriptions\n     * @returns OpenCascade shapes\n     * @group on multiple shapes\n     * @shortname translations\n     * @drawable true\n     */\n    translateShapes(inputs: Inputs.OCCT.TranslateShapesDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer[]>;\n    /**\n     * Scales the shapes with scale factors\n     * @param inputs Scale descriptions\n     * @returns OpenCascade shapes\n     * @group on multiple shapes\n     * @shortname scales\n     * @drawable true\n     */\n    scaleShapes(inputs: Inputs.OCCT.ScaleShapesDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer[]>;\n    /**\n     * Scales the shape in 3D\n     * @param inputs Scale 3D descriptions\n     * @returns OpenCascade scaled shapes\n     * @group on multiple shapes\n     * @shortname scales 3d\n     * @drawable true\n     */\n    scale3dShapes(inputs: Inputs.OCCT.Scale3DShapesDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer[]>;\n    /**\n     * Mirrors the shapes with multiple mirrors\n     * @param inputs Mirror axis origins, axis directions and shapes\n     * @returns OpenCascade shapes\n     * @group on multiple shapes\n     * @shortname mirrors\n     * @drawable true\n     */\n    mirrorShapes(inputs: Inputs.OCCT.MirrorShapesDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer[]>;\n    /**\n     * Mirrors the shapes along the normal and origin\n     * @param inputs Normals for mirroring with origins\n     * @returns OpenCascade shapes\n     * @group on multiple shapes\n     * @shortname mirrors normal\n     * @drawable true\n     */\n    mirrorAlongNormalShapes(inputs: Inputs.OCCT.MirrorAlongNormalShapesDto<Inputs.OCCT.TopoDSShapePointer>): Promise<Inputs.OCCT.TopoDSShapePointer[]>;\n}";
